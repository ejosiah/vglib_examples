#version 460
#extension GL_EXT_scalar_block_layout : enable

#define NUM_VERTICES 8
#define NUM_EDGES 12
#define MAX_TRIANGLE_VERTICES 16

struct Vertex {
    vec4 position;
    vec4 color;
    vec3 normal;
    vec3 tangent;
    vec3 bitangent;
    vec2 uv;
};

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 0, binding = 0) uniform sampler3D Voxels;

layout(set = 0, binding = 1) buffer Params {
    mat4 worldToVoxelTransform;
    mat4 voxelToWordTransform;
    int numVoxels;
};


layout(set = 1, binding = 0, scalar) uniform EDGE_TABLE{
    uint edgeTable[256];
};
layout(set = 1, binding = 1, scalar) uniform TRI_TABLE{
    int triTable[4096];
};


layout(set = 2, binding = 0) buffer MESH_ATTRIBUTES {
    Vertex mesh[];
};

layout(set = 2, binding = 1) buffer IndexBuffer {
    uint indices[];
};

layout(set = 2, binding = 2) buffer ATOMIC_COUNTERS{
    uint vertexCount;
};

layout(set = 2, binding = 3, scalar) buffer IndirecDrawBuffer {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
} draw;

layout(push_constant) uniform Constants{
    vec3 bmin;
    float cubeSize;

    vec3 bmax;
    float isoLevel;
};

const vec3 UnitCube[NUM_VERTICES] = {
    vec3(0, 0, 0),
    vec3(1, 0, 0),
    vec3(1, 0, 1),
    vec3(0, 0, 1),
    vec3(0, 1, 0),
    vec3(1, 1, 0),
    vec3(1, 1, 1),
    vec3(0, 1, 1),
};
vec3 cube[NUM_VERTICES];

const ivec2 cubeEdges[NUM_EDGES] = {
    ivec2(0, 1), ivec2(1, 2), ivec2(2, 3), ivec2(3, 0),
    ivec2(4, 5), ivec2(5, 6), ivec2(6, 7), ivec2(7, 4),
    ivec2(0, 4), ivec2(1, 5), ivec2(2, 6), ivec2(3, 7)
};

vec3 vertexList[NUM_EDGES];
float isoValues[NUM_VERTICES];
vec3 triangles[MAX_TRIANGLE_VERTICES];
vec3 triNormals[MAX_TRIANGLE_VERTICES];

bool outOfBounds(vec3 pos);
void initCubeVertices();
float getIsoValue(vec3 pos, int index);
vec3 getVertex(vec3 center, int edgeIndex);

vec3 voxelsDim = vec3(textureSize(Voxels, 0));

void main() {
    vec3 pos = bmin + (vec3(gl_GlobalInvocationID) + 0.5) * cubeSize;

    if(outOfBounds(pos)) return;

    int config = 0;
    initCubeVertices();

    for(int i = 0; i < 8; i++){
        isoValues[i] = getIsoValue(pos, i);
        if(isoValues[i] < isoLevel){
            config |= (1 << i);
        }
    }

    if(edgeTable[config] == 0) return;

    for(int edge = 0; edge < NUM_EDGES; edge++){
        if((edgeTable[config] & (1 << edge)) != 0){
            vertexList[edge] = getVertex(pos, edge);
        }
    }

    uint numVertices = 0;
    for(int i = config * MAX_TRIANGLE_VERTICES; triTable[i] != -1; i+= 3){
        vec3 p0 = vertexList[triTable[i]];
        vec3 p1 = vertexList[triTable[i + 1]];
        vec3 p2 = vertexList[triTable[i + 2]];

        vec3 e0 = p1 - p0;
        vec3 e1 = p2 - p0;
        vec3 N = normalize(cross(e0, e1));

        triangles[numVertices] = p0;
        triNormals[numVertices++] = N;

        triangles[numVertices] = p1;
        triNormals[numVertices++] = N;

        triangles[numVertices] = p2;
        triNormals[numVertices++] = N;
    }


    uint offset = atomicAdd(draw.indexCount, numVertices);
    atomicAdd(vertexCount, numVertices);
    for(int i = 0; i < numVertices; i++){
        mesh[i + offset].position = vec4(triangles[i], 1);
        mesh[i + offset].normal = triNormals[i];
        mesh[i + offset].color = vec4(1, 1, 0, 1);
        indices[i + offset] = i + offset;
    }
}

void initCubeVertices() {
    for(int i = 0; i < NUM_VERTICES; ++i) {
        cube[i] = UnitCube[i] * cubeSize;
    }
}

float getIsoValue(vec3 center, int index){
    vec4 p = vec4(center + cube[index], 1);
    vec3 tc = (worldToVoxelTransform * p).xyz;
    tc += 0.5/voxelsDim;
    return texture(Voxels,tc).r;
}

vec3 getVertex(vec3 center, int edgeIndex) {
    ivec2 edge = cubeEdges[edgeIndex];
    vec3 p0 = center + cube[edge[0]];
    vec3 p1 = center + cube[edge[1]];

    float isoVal0 = isoValues[edge[0]];
    float isoVal1 = isoValues[edge[1]];
    float t = (isoLevel - isoVal0)/(isoVal1 - isoVal0);

    return mix(p0, p1, t);
}

bool outOfBounds(vec3 pos) {
    bvec3 near = lessThan(pos, bmin);
    bvec3 far = greaterThanEqual(pos, bmax);

    return any(near) || any(far);
}