#version 460

layout(local_size_x = 10) in;

layout(set = 0, binding = 0) buffer Points {
    vec2 generators[];
};

layout(set = 0, binding = 2) buffer Sums {
    vec4 regions[];
};

layout(set = 0, binding = 3) buffer Density {
    int offsets[];
};

layout(set = 0, binding = 4) buffer Centers {
    vec2 centroids[];
};

layout(push_constant) uniform Constants {
    int renderCentroid;
    float threshold;
    float convergenceRate;
    int screenWidth;
    int screenHeight;
    int numGenerators;
};

shared vec4 localRegions[3072];

void main() {
    int voronoiArea = screenWidth * screenHeight;
    int localId = int(gl_LocalInvocationID.x);
    int gid = int(gl_GlobalInvocationID.x);
    int groupSize = int(gl_WorkGroupSize.x);
    int firstGen  = int(gl_WorkGroupID.x * gl_WorkGroupSize.x);
    int numGen = min(firstGen + int(gl_WorkGroupSize.x), numGenerators);
    int end = numGen < numGenerators ? offsets[numGen] - offsets[firstGen] : voronoiArea;

    if(gid > numGenerators) return;

    for(int i = localId; i < end; i += groupSize) {
        localRegions[i] = regions[i + firstGen];
    }

    barrier();
    
    int startOffset = firstGen + gid;
    int start = offsets[startOffset];
    int endIdx = startOffset + 1;
    end = endIdx < gl_NumWorkGroups.x ? offsets[endIdx] : voronoiArea;
    int N = end - start;
    
    start -= firstGen;
    end = start + N;

    vec2 sum = vec2(0);
    for(int i = start; i < end; i++){
        sum += localRegions[i].xy;
    }

    vec2 center = sum/N;
    vec2 gPoint = generators[gid];

    vec2 d = center - gPoint;

    if(dot(d, d) > threshold) {
        vec2 newGPoint = mix(gPoint, center, convergenceRate);
        generators[gid] = newGPoint;
    }
    centroids[gid] = center;
}