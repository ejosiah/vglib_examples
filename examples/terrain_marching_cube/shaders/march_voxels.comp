#version 460
#include "models.glsl"
#include "cuckoo_hash_functions.glsl"

#define NUM_VERTICES 8
#define NUM_EDGES 12
#define MAX_TRIANGLE_VERTICES 16

layout(local_size_x = 32, local_size_y = 1, local_size_z = 32) in;

layout(set = 3, binding = 0, scalar) uniform EDGE_TABLE{
    uint edgeTable[256];
};
layout(set = 3, binding = 1, scalar) uniform TRI_TABLE{
    int triTable[4096];
};

layout(push_constant) uniform Constants {
    int pass;
};

const ivec3 cube[NUM_VERTICES] = {
    ivec3(0, 0, 0),
    ivec3(1, 0, 0),
    ivec3(1, 0, 1),
    ivec3(0, 0, 1),
    ivec3(0, 1, 0),
    ivec3(1, 1, 0),
    ivec3(1, 1, 1),
    ivec3(0, 1, 1),
};

const ivec2 cubeEdges[NUM_EDGES] = {
    ivec2(0, 1), ivec2(1, 2), ivec2(2, 3), ivec2(3, 0),
    ivec2(4, 5), ivec2(5, 6), ivec2(6, 7), ivec2(7, 4),
    ivec2(0, 4), ivec2(1, 5), ivec2(2, 6), ivec2(3, 7)
};


vec3 vertexList[NUM_EDGES];
float isoValues[NUM_VERTICES];
vec3 triangles[MAX_TRIANGLE_VERTICES];
vec3 triNormals[MAX_TRIANGLE_VERTICES];

vec3 getVertex(vec3 center, int edgeIndex);
float getIsoValue(ivec3 center, int index);

uint block_index = pass * gl_WorkGroupSize.y + gl_WorkGroupID.y;
uint voxel_id = gl_WorkGroupID.y;
shared DrawCommand drawCmd;
shared uint slot;
shared int slot_acquired;

const float cubeSize = 1.0/32.0;
const float isoLevel = 0;

void main() {
    if(counters.free_slots <= 0) return;

    const uint index = pass * gl_WorkGroupSize.y + gl_WorkGroupID.y;
    const uint voxel_id = gl_WorkGroupID.y;

    if(gl_WorkGroupID.x == 0) {
        drawCmd = DrawCommand(0, 1, 0, 0);
        slot_acquired = 0;
    }

    if(block_index >= counters.blocks) return;

    vec3 box_center = block[index].aabb;
    const uint key = compute_hash_key(box_center);

    if(block_already_processed(key)) return;

    const mat4 grid_to_world = camera_info.grid_to_world;
    const vec3 world_position = (grid_to_world * vec4(box_center, 1)).xyz;
    const vec3 start = world_position - vec3(0.5) + vec3(cubeSize) * 0.5;

    for(int y = 0; y < 32; ++y) {
        ivec3 location = ivec3(gl_LocalInvocationID.x, y, gl_LocalInvocationID.z);
        vec3 position = start + vec3(location)/32;

        int config = 0;
        for(int i = 0; i < 8; ++i){
            isoValues[i] = getIsoValue(location, i);
            if(isoValues[i] > isoLevel){
                config |= (1 << i);
            }
        }

        if(edgeTable[config] != 0) continue;

        for(int edge = 0; edge < NUM_EDGES; edge++){
            if((edgeTable[config] & (1 << edge)) != 0){
                vertexList[edge] = getVertex(position, edge);
            }
        }

        uint numVertices = 0;
        for(int i = config * MAX_TRIANGLE_VERTICES; triTable[i] != -1; i+= 3){
            vec3 p0 = vertexList[triTable[i]];
            vec3 p1 = vertexList[triTable[i + 1]];
            vec3 p2 = vertexList[triTable[i + 2]];

            triangles[numVertices++] = p0;
            triangles[numVertices++] = p1;
            triangles[numVertices++] = p2;
        }
        if(numVertices != 0) {
            uint vOffset = atomicAdd(drawCmd.vertexCount, numVertices);

            if(atomicCompSwap(slot_acquired, 0, 1) == 0) {
                slot = atomicAdd(counters.free_slots, 1);
            }
            for(uint i = 0; i < numVertices; ++i) {
                uint vId = i + vOffset;
                vertex[slot].data[vId].position = triangles[i];
            }
        }
    }

    if(gl_WorkGroupID.x == 0 && drawCmd.vertexCount > 0) {
        draw[slot] = drawCmd;
    }
}



float getIsoValue(ivec3 center, int index){
    ivec3 location = center + cube[index];
    return imageLoad(voxels[voxel_id],  location).r;
}

vec3 getVertex(vec3 center, int edgeIndex) {
    ivec2 edge = cubeEdges[edgeIndex];
    vec3 p0 = center + cube[edge[0]];
    vec3 p1 = center + cube[edge[1]];

    float isoVal0 = isoValues[edge[0]];
    float isoVal1 = isoValues[edge[1]];
    float t = (isoLevel - isoVal0)/(isoVal1 - isoVal0);

    return mix(p0, p1, t);
}
