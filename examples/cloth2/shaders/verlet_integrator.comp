#version 460 core

layout(local_size_x = 10, local_size_y = 10) in;

#include "shared.glsl"

layout(set = 0, binding = 0) buffer POINT_MASSES_IN{
    vec4 positions1[];
};

layout(set = 1, binding = 0) buffer POINT_MASS_OUT{
    vec4 positions0[];
};

layout(set = 2, binding = 0) buffer LEVEL_SET_GEOMETRY {
    mat4 worldSpaceXform;
    mat4 localSpaceXform;
    vec3 center;
    float radius;
} geometry;


bool neighbour(int i, out vec3 pos, out vec3 prev_pos, out float ks, out float kd, out float rest_length){
    ivec2 coord;
    int nid;
    if(!neighbour(i, nid, coord)){
        return false;
    }

    pos = positions1[nid].xyz;
    prev_pos = positions0[nid].xyz;

    rest_length = length(coord * inv_cloth_size);
    if(i < 4){
        ks = ksStruct;
        kd = kdStruct;
    }else if(i < 8){
        ks = ksShear;
        kd = kdShear;
    }else if(i < 12){
        ks = ksBend;
        kd = kdBend;
    }

    return true;
}



bool collision(inout vec3 position){
    vec3 p = (geometry.localSpaceXform * vec4(position, 1)).xyz; // bring into sphere local space
    float pd = length(p);
    float d = pd - geometry.radius;

    bool hitGeom = false;
    if(d < EPSILON) {
        vec3 n = p/pd;
        p = n * (geometry.radius + EPSILON);
        position = (geometry.worldSpaceXform * vec4(p, 1)).xyz;
        hitGeom = true;
    }

//    vec3 d = position - geometry.center;
//    float r = (geometry.radius + EPSILON);
//    float dd = dot(d, d);
//    if(length(d) < r){
//        d = normalize(d);
//        position = geometry.center + d * r;
//        hitGeom = true;
//    }

    if(position.y < EPSILON) {
        position.y = EPSILON;
        return true;
    }
    return hitGeom;
}

vec3 calculateNormal(vec3 position){
    ivec2 coord;
    int nid;
    int count = 0;
    vec3 normal = vec3(0);
    for(int i = 1; i <= 4; i++){
        if(!neighbour(i - 1, nid, coord)) continue;
        vec3 A = positions1[nid].xyz - position;

        if(!neighbour(i%4, nid, coord)) continue;
        vec3 B = positions1[nid].xyz - position;
        normal += cross(B, A);
        count++;
    }
    normal /= count;
    return normalize(normal);
}

void main(){
    //    float dt = 0.00083;
    float dt = timeStep;
    float inv_dt = 1/dt;
    vec3 pos = positions1[id].xyz;
    vec3 prev_pos = positions0[id].xyz;
    vec3 velocity = (pos - prev_pos) * inv_dt;

    vec3 force = mass * gravity + kd * -velocity;

    if(bool(simWind)){
        float t = elapsedTime;
        float f = 2 * TWO_PI * windSpeed;
        float amp = windStrength;
        vec3 N = calculateNormal(pos);
        vec3 wind = vec3(0);
        wind.x = amp * sin(pos.x * f + t) * sin(pos.y * f + t);
        wind.y = amp * sin(pos.y * f + t) * sin(pos.z * f + t);
        wind.z = amp * sin(pos.z * f + t) * sin(pos.x * f + t);
        force += kd * abs(dot(wind - velocity, N));
    }

    for(int i = 0; i < 12; i++){
        vec3 nPos;
        vec3 nPrev_pos;
        float ks;
        float kd;
        float l0;

        if(!neighbour(i, nPos, nPrev_pos, ks, kd, l0)){
            continue;
        }

        vec3 d = nPos - pos;
        float l1 = length(d);
        d /= l1;
        vec3 nVelocity = (nPos - nPrev_pos) * inv_dt;

        vec3 f = d * (ks * (l1 - l0) + kd * dot(nVelocity - velocity, d));

        force += f;
    }

    float inv_mass = 1.0f/mass;
//    if(id == (numPoints - width) || id == (numPoints - 1)){
//        inv_mass = 0;
//    }

    vec3 a = force * inv_mass;

    vec3 p = 2 * pos - prev_pos + a * dt * dt;

    if(collision(p)) {
        pos = p;
    }

    positions0[id] = vec4(pos, 1);
    positions1[id] = vec4(p, 1);
}